(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{106:function(e,r,t){"use strict";t.d(r,"a",(function(){return d})),t.d(r,"b",(function(){return m}));var n=t(0),a=t.n(n);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function c(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?c(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function l(e,r){if(null==e)return{};var t,n,a=function(e,r){if(null==e)return{};var t,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],r.indexOf(t)>=0||(a[t]=e[t]);return a}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var b=a.a.createContext({}),s=function(e){var r=a.a.useContext(b),t=r;return e&&(t="function"==typeof e?e(r):i(i({},r),e)),t},d=function(e){var r=s(e.components);return a.a.createElement(b.Provider,{value:r},e.children)},p={inlineCode:"code",wrapper:function(e){var r=e.children;return a.a.createElement(a.a.Fragment,{},r)}},u=a.a.forwardRef((function(e,r){var t=e.components,n=e.mdxType,o=e.originalType,c=e.parentName,b=l(e,["components","mdxType","originalType","parentName"]),d=s(t),u=n,m=d["".concat(c,".").concat(u)]||d[u]||p[u]||o;return t?a.a.createElement(m,i(i({ref:r},b),{},{components:t})):a.a.createElement(m,i({ref:r},b))}));function m(e,r){var t=arguments,n=r&&r.mdxType;if("string"==typeof e||n){var o=t.length,c=new Array(o);c[0]=u;var i={};for(var l in r)hasOwnProperty.call(r,l)&&(i[l]=r[l]);i.originalType=e,i.mdxType="string"==typeof e?e:n,c[1]=i;for(var b=2;b<o;b++)c[b]=t[b];return a.a.createElement.apply(null,c)}return a.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},70:function(e,r,t){"use strict";t.r(r),t.d(r,"frontMatter",(function(){return c})),t.d(r,"metadata",(function(){return i})),t.d(r,"rightToc",(function(){return l})),t.d(r,"default",(function(){return s}));var n=t(2),a=t(6),o=(t(0),t(106)),c={id:"word-search",title:"Word Search"},i={unversionedId:"word-search",id:"word-search",isDocsHomePage:!1,title:"Word Search",description:"Problem",source:"@site/docs/79.word-search.md",slug:"/word-search",permalink:"/docs/word-search",editUrl:"https://github.com/techfellows/website/edit/master/website/docs/docs/79.word-search.md",version:"current",sidebar:"algorithmsAndDataStructuresSidebar",previous:{title:"Maximum Sum Subarray",permalink:"/docs/maximum-sum-subarray"},next:{title:"Subsets II",permalink:"/docs/subsets-ii"}},l=[{value:"Problem",id:"problem",children:[]},{value:"Problem Description",id:"problem-description",children:[]},{value:"Solution",id:"solution",children:[]},{value:"Key Points",id:"key-points",children:[]},{value:"Code (<code>Java/Javascript/Python3</code>)",id:"code-javajavascriptpython3",children:[]},{value:"References",id:"references",children:[]}],b={rightToc:l};function s(e){var r=e.components,t=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},b,t,{components:r,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"problem"},"Problem"),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://leetcode.com/problems/word-search/"}),"https://leetcode.com/problems/word-search/")),Object(o.b)("h2",{id:"problem-description"},"Problem Description"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"Given a 2D board and a word, find if the word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\nExample:\n\nboard =\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n\nGiven word = \"ABCCED\", return true.\nGiven word = \"SEE\", return true.\nGiven word = \"ABCB\", return false.\n")),Object(o.b)("h2",{id:"solution"},"Solution"),Object(o.b)("p",null,"This problem does not give start position, or direction restriction, so"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Scan board, find starting position with matching word first letter"),Object(o.b)("li",{parentName:"ol"},"From starting position, DFS (4 (up, down, left, right 4 directions) match word's rest letters"),Object(o.b)("li",{parentName:"ol"},"For each visited letter, mark it as visited, here use ",Object(o.b)("inlineCode",{parentName:"li"},"board[i][j] = '*'")," to represent visited."),Object(o.b)("li",{parentName:"ol"},"If one direction cannot continue, backtracking, mark start position unvisited, mark ",Object(o.b)("inlineCode",{parentName:"li"},"board[i][j] = word[start]")),Object(o.b)("li",{parentName:"ol"},"If found any matching, terminate"),Object(o.b)("li",{parentName:"ol"},"Otherwise, no matching found, return false.")),Object(o.b)("p",null,"For example:"),Object(o.b)("p",null,"board, word\uff1a",Object(o.b)("inlineCode",{parentName:"p"},"SEE")," as below pic:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"1. Scan board, found board[1,0] = word[0]\uff0cmatch word first letter\u3002\n2. DFS\uff08up, down, left, right 4 directions\uff09\n\nas below pic:\n")),Object(o.b)("p",null,Object(o.b)("img",Object(n.a)({parentName:"p"},{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghltxkrpz0j30zh0bita5.jpg",alt:"word search 1"}))),Object(o.b)("p",null,"Staring position\uff081\uff0c0), check whether adjacent cells match word next letter ",Object(o.b)("inlineCode",{parentName:"p"},"E"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"1. mark current position\uff081\uff0c0\uff09as visited\uff0cboard[1][0] = '*'\n2. Up\uff080\uff0c0\uff09letter='A' not match,\n3. Down\uff082\uff0c0\uff09letter='A'\uff0cnot match,\n4. Left\uff08-1\uff0c0\uff09out of board boundry\uff0cnot match,\n5. right\uff081\uff0c1\uff09letter='F'\uff0cnot match\n\nas below pic:\n")),Object(o.b)("p",null,Object(o.b)("img",Object(n.a)({parentName:"p"},{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghltxldusrj30wk0fqdhj.jpg",alt:"word search 2"}))),Object(o.b)("p",null,"Didn't find matching from starting position, so"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"1. backtracking\uff0cmart start position\uff081\uff0c0\uff09as unvisited, board[1][0] = 'S'.\n2. scan board, find next start position\uff081\uff0c3\uff09which match word first letter\n\nas below pic:\n")),Object(o.b)("p",null,Object(o.b)("img",Object(n.a)({parentName:"p"},{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghltxm8h3zj30xm0czdha.jpg",alt:"word search 3"}))),Object(o.b)("p",null,"New starting position\uff081\uff0c3\uff09\uff0ccheck whether adjacent cells match word next letter ",Object(o.b)("inlineCode",{parentName:"p"},"E"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"1. mark current position\uff081, 3\uff09as already visited\uff0cboard[1][3] = '*'\n2. Up\uff080\uff0c3\uff09letter='E', match, continue DFS search\uff0crefer position\uff080\uff0c3\uff09DFS search steps.\n3. Down\uff082\uff0c3\uff09letter='E'\uff0cmatch, since #2 DFS didn't find word matching, continue DFS search, rfer to position (2, 3) DFS search steps.\n4. Left\uff081\uff0c2\uff09letter='C'\uff0cnot match,\n5. Right\uff081\uff0c4\uff09out of board boundry\uff0cnot match\n\nas below pic:\n")),Object(o.b)("p",null,Object(o.b)("img",Object(n.a)({parentName:"p"},{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghltxn5k3xj30yi0ebq4o.jpg",alt:"word search 4"}))),Object(o.b)("p",null,"Start position\uff080\uff0c3), DFS\uff0ccheck whether adjacent cells match word next letter ",Object(o.b)("inlineCode",{parentName:"p"},"E")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"1. marck current position\uff080\uff0c3\uff09already visited\uff0cboard[0][3] = '*'\n2. Up \uff08-1\uff0c3\uff09out of board boundry\uff0cnot match\n3. Down\uff081\uff0c3\uff09already visited\uff0c\n4. Left\uff080\uff0c2\uff09letter='C'\uff0cnot match\n5. Right\uff081\uff0c4\uff09out of board boundry\uff0cnot match\n\nas below pic:\n")),Object(o.b)("p",null,Object(o.b)("img",Object(n.a)({parentName:"p"},{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghltxnk3ldj30tr0blq43.jpg",alt:"word search 5"}))),Object(o.b)("p",null,"Start from position\uff080\uff0c3\uff09not matching word, start position (2, 3) DFS search:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"1. Backtracking\uff0cmark\uff080\uff0c3\uff09as unvisited\u3002board[0][3] = 'E'.\n2. Backtracking to next position\uff082\uff0c3\uff09\uff0cDFS\uff0ccheck whether adjacent cells match word next letter 'E'\n3. Up (1\uff0c3\uff09visited, continue\n4. Down\uff083\uff0c3\uff09out of board boundry\uff0cnot match\n5. Left\uff082\uff0c2\uff09letter='E', match\n6. Right\uff082\uff0c4\uff09out of board boundry\uff0cnot match\n\nas below pic:\n")),Object(o.b)("p",null,Object(o.b)("img",Object(n.a)({parentName:"p"},{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghltxnznr2j30v50chmyf.jpg",alt:"word search 6"}))),Object(o.b)("p",null,"Found match with word, return ",Object(o.b)("inlineCode",{parentName:"p"},"True"),".\n",Object(o.b)("img",Object(n.a)({parentName:"p"},{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghltxowzgej30y90bo3zv.jpg",alt:"word search 7"}))),Object(o.b)("h4",{id:"complexity-analysis"},"Complexity Analysis"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"Time Complexity:")," ",Object(o.b)("inlineCode",{parentName:"li"},"O(m*n) - m is number of board rows, n is number of board columns")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"Space Complexity:")," ",Object(o.b)("inlineCode",{parentName:"li"},"O(1) - no extra space"))),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},Object(o.b)("strong",{parentName:"p"},"Note"),"\uff1aif use Set or boolean","[][]"," mark position visited\uff0cneed extra space ",Object(o.b)("inlineCode",{parentName:"p"},"O(m*n)"),".")),Object(o.b)("h2",{id:"key-points"},"Key Points"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Scan board, find start position which match word first letter, DFS"),Object(o.b)("li",{parentName:"ul"},"Remember visited letter"),Object(o.b)("li",{parentName:"ul"},"Backtracking if not found matching")),Object(o.b)("h2",{id:"code-javajavascriptpython3"},"Code (",Object(o.b)("inlineCode",{parentName:"h2"},"Java/Javascript/Python3"),")"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Java Code")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"public class LC79WordSearch {\n  public boolean exist(char[][] board, String word) {\n    if (board == null || word == null) return false;\n    if (word.length() == 0) return true;\n    if (board.length == 0) return false;\n    int rows = board.length;\n    int cols = board[0].length;\n    for (int r = 0; r < rows; r++) {\n      for (int c = 0; c < cols; c++) {\n        // scan board, start with word first character\n        if (board[r][c] == word.charAt(0)) {\n          if (helper(board, word, r, c, 0)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  private boolean helper(char[][] board, String word, int r, int c, int start) {\n    // already match word all characters, return true\n    if (start == word.length()) return true;\n    if (!isValid(board, r, c) ||\n        board[r][c] != word.charAt(start)) return false;\n    // mark visited\n    board[r][c] = '*';\n    boolean res = helper(board, word, r + 1, c, start + 1)\n        ||  helper(board, word, r, c + 1, start + 1)\n        ||  helper(board, word, r - 1, c, start + 1)\n        ||  helper(board, word, r, c - 1, start + 1);\n    // backtracking to start position\n    board[r][c] = word.charAt(start);\n    return res;\n  }\n\n  private boolean isValid(char[][] board, int r, int c) {\n    return r >= 0 && r < board.length && c >= 0 && c < board[0].length;\n  }\n}\n")),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Python3 Code")),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        m = len(board)\n        n = len(board[0])\n\n        def dfs(board, r, c, word, index):\n            if index == len(word):\n                return True\n            if r < 0 or r >= m or c < 0 or c >= n or board[r][c] != word[index]:\n                return False\n            board[r][c] = '*'\n            res = dfs(board, r - 1, c, word, index + 1) or dfs(board, r + 1, c, word, index + 1) or dfs(board, r, c - 1, word, index + 1) or dfs(board, r, c + 1, word, index + 1)\n            board[r][c] = word[index]\n            return res\n\n        for r in range(m):\n            for c in range(n):\n                if board[r][c] == word[0]:\n                    if dfs(board, r, c, word, 0):\n                        return True\n")),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Javascript Code")," from ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/azl397985856"}),Object(o.b)("strong",{parentName:"a"},"@lucifer"))),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-javascript"}),"/*\n * @lc app=leetcode id=79 lang=javascript\n *\n * [79] Word Search\n */\nfunction DFS(board, row, col, rows, cols, word, cur) {\n  // \u8fb9\u754c\u68c0\u67e5\n  if (row >= rows || row < 0) return false;\n  if (col >= cols || col < 0) return false;\n\n  const item = board[row][col];\n\n  if (item !== word[cur]) return false;\n\n  if (cur + 1 === word.length) return true;\n\n  // If use HashMap keep track visited letters, then need manual clear HashMap for each backtrack which needs extra space.\n  // here we use a little trick\n  board[row][col] = null;\n\n  // UP, DOWN, LEFT, RIGHT\n  const res =\n    DFS(board, row + 1, col, rows, cols, word, cur + 1) ||\n    DFS(board, row - 1, col, rows, cols, word, cur + 1) ||\n    DFS(board, row, col - 1, rows, cols, word, cur + 1) ||\n    DFS(board, row, col + 1, rows, cols, word, cur + 1);\n\n  board[row][col] = item;\n\n  return res;\n}\n/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function (board, word) {\n  if (word.length === 0) return true;\n  if (board.length === 0) return false;\n\n  const rows = board.length;\n  const cols = board[0].length;\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      const hit = DFS(board, i, j, rows, cols, word, 0);\n      if (hit) return true;\n    }\n  }\n  return false;\n};\n")),Object(o.b)("h2",{id:"references"},"References"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://www.wikiwand.com/en/Backtracking"}),"Backtracking Wiki"))))}s.isMDXComponent=!0}}]);