(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{106:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var r=n(0),i=n.n(r);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),u=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=u(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=i.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(n),m=r,d=p["".concat(o,".").concat(m)]||p[m]||b[m]||s;return n?i.a.createElement(d,a(a({ref:t},l),{},{components:n})):i.a.createElement(d,a({ref:t},l))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=m;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a.mdxType="string"==typeof e?e:r,o[1]=a;for(var l=2;l<s;l++)o[l]=n[l];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},74:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return a})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));var r=n(2),i=n(6),s=(n(0),n(106)),o={id:"subsets-ii",title:"Subsets II"},a={unversionedId:"subsets-ii",id:"subsets-ii",isDocsHomePage:!1,title:"Subsets II",description:"Problem Link",source:"@site/docs/90.subsets-ii.md",slug:"/subsets-ii",permalink:"/docs/subsets-ii",editUrl:"https://github.com/techfellows/website/edit/master/website/docs/docs/90.subsets-ii.md",version:"current",sidebar:"algorithmsAndDataStructuresSidebar",previous:{title:"Word Search",permalink:"/docs/word-search"}},c=[{value:"Problem Link",id:"problem-link",children:[]},{value:"Description",id:"description",children:[]},{value:"Solution",id:"solution",children:[]},{value:"Key Points",id:"key-points",children:[]},{value:"Code",id:"code",children:[]}],l={rightToc:c};function u(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(s.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("h2",{id:"problem-link"},"Problem Link"),Object(s.b)("p",null,Object(s.b)("a",Object(r.a)({parentName:"p"},{href:"https://leetcode.com/problems/subsets-ii/description/"}),"https://leetcode.com/problems/subsets-ii/description/")),Object(s.b)("h2",{id:"description"},"Description"),Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{}),"Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\n\nNote: The solution set must not contain duplicate subsets.\n\nExample:\n\nInput: [1,2,2]\nOutput:\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]\n\n")),Object(s.b)("h2",{id:"solution"},"Solution"),Object(s.b)("p",null,"Since this problem is seeking ",Object(s.b)("inlineCode",{parentName:"p"},"Subset")," not ",Object(s.b)("inlineCode",{parentName:"p"},"Extreme Value"),", dynamic programming is not an ideal solution. Other approaches should be taken into our consideration."),Object(s.b)("p",null,"Actually, there is a general approach to solve problems similar to this one -- backtracking. Given a ",Object(s.b)("a",Object(r.a)({parentName:"p"},{href:"https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)"}),"Code Template")," here, it demonstrates how backtracking works with varieties of problems. Apart from current one, many problems can be solved by such a general approach. For more details, please check the ",Object(s.b)("inlineCode",{parentName:"p"},"Related Problems")," section below."),Object(s.b)("p",null,"Given a picture as followed, let's start with problem-solving ideas of this general solution."),Object(s.b)("p",null,Object(s.b)("img",Object(r.a)({parentName:"p"},{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghlu843pcgj30n20nptas.jpg",alt:"backtrack"}))),Object(s.b)("p",null,"See Code Template details below."),Object(s.b)("h2",{id:"key-points"},"Key Points"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Backtrack Approach"),Object(s.b)("li",{parentName:"ul"},"Backtrack Code Template/ Formula")),Object(s.b)("h2",{id:"code"},"Code"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Supported Language\uff1aJS\uff0cC++\uff0cPython3")),Object(s.b)("p",null,"JavaScript Code\uff1a"),Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"/*\n * @lc app=leetcode id=90 lang=javascript\n *\n * [90] Subsets II\n *\n * https://leetcode.com/problems/subsets-ii/description/\n *\n * algorithms\n * Medium (41.53%)\n * Total Accepted:    197.1K\n * Total Submissions: 469.1K\n * Testcase Example:  '[1,2,2]'\n *\n * Given a collection of integers that might contain duplicates, nums, return\n * all possible subsets (the power set).\n *\n * Note: The solution set must not contain duplicate subsets.\n *\n * Example:\n *\n *\n * Input: [1,2,2]\n * Output:\n * [\n * \u2060 [2],\n * \u2060 [1],\n * \u2060 [1,2,2],\n * \u2060 [2,2],\n * \u2060 [1,2],\n * \u2060 []\n * ]\n *\n *\n */\nfunction backtrack(list, tempList, nums, start) {\n  list.push([...tempList]);\n  for (let i = start; i < nums.length; i++) {\n    //nums can be duplicated, which is different from Problem 78 - subsets\n    //So the situation should be taken into consideration\n    if (i > start && nums[i] === nums[i - 1]) continue;\n    tempList.push(nums[i]);\n    backtrack(list, tempList, nums, i + 1);\n    tempList.pop();\n  }\n}\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsetsWithDup = function (nums) {\n  const list = [];\n  backtrack(\n    list,\n    [],\n    nums.sort((a, b) => a - b),\n    0,\n    []\n  );\n  return list;\n};\n")),Object(s.b)("p",null,"C++ Code\uff1a"),Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-C++"}),"class Solution {\nprivate:\n    void subsetsWithDup(vector<int>& nums, size_t start, vector<int>& tmp, vector<vector<int>>& res) {\n        res.push_back(tmp);\n        for (auto i = start; i < nums.size(); ++i) {\n            if (i > start && nums[i] == nums[i - 1]) continue;\n            tmp.push_back(nums[i]);\n            subsetsWithDup(nums, i + 1, tmp, res);\n            tmp.pop_back();\n        }\n    }\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        auto tmp = vector<int>();\n        auto res = vector<vector<int>>();\n        sort(nums.begin(), nums.end());\n        subsetsWithDup(nums, 0, tmp, res);\n        return res;\n    }\n};\n")),Object(s.b)("p",null,"Python Code:"),Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-Python"}),'class Solution:\n    def subsetsWithDup(self, nums: List[int], sorted: bool=False) -> List[List[int]]:\n        """Backtrack Approach: by sorting parameters first to avoid repeting sort later"""\n        if not nums:\n            return [[]]\n        elif len(nums) == 1:\n            return [[], nums]\n        else:\n            # Sorting first to filter duplicated numbers\n            # Note\uff0cthis problem takes higher time complexity\n            # So, it could greatly improve time efficiency by adding one parameter to avoid repeting sort in following procedures\n            if not sorted:\n                nums.sort()\n            # Backtrack Approach\n            pre_lists = self.subsetsWithDup(nums[:-1], sorted=True)\n            all_lists = [i+[nums[-1]] for i in pre_lists] + pre_lists\n            # distinct elements\n            result = []\n            for i in all_lists:\n                if i not in result:\n                    result.append(i)\n            return result\n')))}u.isMDXComponent=!0}}]);