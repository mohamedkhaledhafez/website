(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{106:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return m}));var r=t(0),l=t.n(r);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,l=function(e,n){if(null==e)return{};var t,r,l={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var u=l.a.createContext({}),s=function(e){var n=l.a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=s(e.components);return l.a.createElement(u.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return l.a.createElement(l.a.Fragment,{},n)}},b=l.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=s(t),b=r,m=d["".concat(i,".").concat(b)]||d[b]||p[b]||a;return t?l.a.createElement(m,o(o({ref:n},u),{},{components:t})):l.a.createElement(m,o({ref:n},u))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=b;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var u=2;u<a;u++)i[u]=t[u];return l.a.createElement.apply(null,i)}return l.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},59:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return o})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return s}));var r=t(2),l=t(6),a=(t(0),t(106)),i={id:"add-two-numbers",title:"Add Two Numbers"},o={unversionedId:"add-two-numbers",id:"add-two-numbers",isDocsHomePage:!1,title:"Add Two Numbers",description:"Problem",source:"@site/docs/2.add-two-numbers.md",slug:"/add-two-numbers",permalink:"/docs/add-two-numbers",editUrl:"https://github.com/techfellows/website/edit/master/website/docs/docs/2.add-two-numbers.md",version:"current",sidebar:"algorithmsAndDataStructuresSidebar",previous:{title:"Two Sum",permalink:"/docs/two-sum"},next:{title:"Trapping Rain Water",permalink:"/docs/trapping-rain-water"}},c=[{value:"Problem",id:"problem",children:[]},{value:"Problem Description",id:"problem-description",children:[]},{value:"Solution",id:"solution",children:[]},{value:"Key Point Analysis",id:"key-point-analysis",children:[]},{value:"Code",id:"code",children:[]},{value:"Extension",id:"extension",children:[{value:"Description",id:"description",children:[]},{value:"C++ Implementation",id:"c-implementation",children:[]}]}],u={rightToc:c};function s(e){var n=e.components,t=Object(l.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},u,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"problem"},"Problem"),Object(a.b)("p",null,Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://leetcode.com/problems/add-two-numbers/description/"}),"https://leetcode.com/problems/add-two-numbers/description/")),Object(a.b)("h2",{id:"problem-description"},"Problem Description"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nExample\n\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\nExplanation: 342 + 465 = 807.\n\n")),Object(a.b)("h2",{id:"solution"},"Solution"),Object(a.b)("p",null,"Define a new variable ",Object(a.b)("inlineCode",{parentName:"p"},"carried")," that represents the carry value during the calculation, and a new linked list",Object(a.b)("br",{parentName:"p"}),"\n","Traverse the two linked lists from the start to the end simultaneously, and calculate the sum of node value from each linked list. The sum of the result and ",Object(a.b)("inlineCode",{parentName:"p"},"carried")," would be appended as a new node to the end of the new linked list."),Object(a.b)("p",null,Object(a.b)("img",Object(r.a)({parentName:"p"},{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghludjiguqg30qh0eon5c.gif",alt:"2.addTwoNumbers"}))),Object(a.b)("p",null,"(Image Reference: ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/MisterBooo/LeetCodeAnimation"}),"https://github.com/MisterBooo/LeetCodeAnimation"),")"),Object(a.b)("h2",{id:"key-point-analysis"},"Key Point Analysis"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"The characteristics and application of this data structure - linked list")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Define a variable named ",Object(a.b)("inlineCode",{parentName:"p"},"carried")," to replace the role of carry-over, calculate ",Object(a.b)("inlineCode",{parentName:"p"},"carried")," after each sum and apply it to the next round's calculation"))),Object(a.b)("h2",{id:"code"},"Code"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Language Support: JS, C++")),Object(a.b)("p",null,"JavaScript:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  if (l1 === null || l2 === null) return null;\n\n  // using dummyHead can simplify linked list's calculation, dummyHead.next points to the new linked list\n  let dummyHead = new ListNode(0);\n  let cur1 = l1;\n  let cur2 = l2;\n  let cur = dummyHead; // cur is for the calculation in new linked list\n  let carry = 0; // carry-over symbol\n\n  while (cur1 !== null || cur2 !== null) {\n    let val1 = cur1 !== null ? cur1.val : 0;\n    let val2 = cur2 !== null ? cur2.val : 0;\n    let sum = val1 + val2 + carry;\n    let newNode = new ListNode(sum % 10); // the result of sum%10 ranges from 0 to 9, which is the value of the current digit\n    carry = sum >= 10 ? 1 : 0; // sum>=10, carry=1, so carry-over exists here\n    cur.next = newNode;\n    cur = cur.next;\n\n    if (cur1 !== null) {\n      cur1 = cur1.next;\n    }\n\n    if (cur2 !== null) {\n      cur2 = cur2.next;\n    }\n  }\n\n  if (carry > 0) {\n    // If there's still carry-over in the end, then add a new node\n    cur.next = new ListNode(carry);\n  }\n\n  return dummyHead.next;\n};\n")),Object(a.b)("p",null,"C++"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"C++ code is slightly different from the JavaScript code above: the step that checks whether carry equals to 0 is put in the while-loop.")),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-c++"}),"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* ret = nullptr;\n        ListNode* cur = nullptr;\n        int carry = 0;\n        while (l1 != nullptr || l2 != nullptr || carry != 0) {\n            carry += (l1 == nullptr ? 0 : l1->val) + (l2 == nullptr ? 0 : l2->val);\n            auto temp = new ListNode(carry % 10);\n            carry /= 10;\n            if (ret == nullptr) {\n                ret = temp;\n                cur = ret;\n            }\n            else {\n                cur->next = temp;\n                cur = cur->next;\n            }\n            l1 = l1 == nullptr ? nullptr : l1->next;\n            l2 = l2 == nullptr ? nullptr : l2->next;\n        }\n        return ret;\n    }\n};\n")),Object(a.b)("h2",{id:"extension"},"Extension"),Object(a.b)("p",null,"The singly-linked list also has a recursive structure based on its definition. Therefore, the recursive apporach works on reversing a linked list, as well."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Because a singly-linked list is a linear data structure, the recursive approach means that the use of stack would also be linear. When the linked list's length reaches a certain level, the recursion would result in a stack overflow. Therefore, using recursion to manipulate a linked list is not recommended in reality.")),Object(a.b)("h3",{id:"description"},"Description"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Add up the first node of two linked lists, and covert the result to a number between 0 and 10, record the carry-over as well."),Object(a.b)("li",{parentName:"ol"},"Proceed to add up the two linked lists after the first node with carry-over recursively"),Object(a.b)("li",{parentName:"ol"},"Point the next of the head node from the first step to the linked list returned from the second step")),Object(a.b)("h3",{id:"c-implementation"},"C++ Implementation"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-C++"}),"// Normal recursion\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        return addTwoNumbers(l1, l2, 0);\n    }\n\nprivate:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2, int carry) {\n        if (l1 == nullptr && l2 == nullptr && carry == 0) return nullptr;\n        carry += (l1 == nullptr ? 0 : l1->val) + (l2 == nullptr ? 0 : l2->val);\n        auto ret = new ListNode(carry % 10);\n        ret->next = addTwoNumbers(l1 == nullptr ? l1 : l1->next,\n                                 l2 == nullptr ? l2 : l2->next,\n                                 carry / 10);\n        return ret;\n    }\n};\n// (Similiar) Tail recursion\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* head = nullptr;\n        addTwoNumbers(head, nullptr, l1, l2, 0);\n        return head;\n    }\n\nprivate:\n    void addTwoNumbers(ListNode*& head, ListNode* cur, ListNode* l1, ListNode* l2, int carry) {\n        if (l1 == nullptr && l2 == nullptr && carry == 0) return;\n        carry += (l1 == nullptr ? 0 : l1->val) + (l2 == nullptr ? 0 : l2->val);\n        auto temp = new ListNode(carry % 10);\n        if (cur == nullptr) {\n            head = temp;\n            cur = head;\n        } else {\n            cur->next = temp;\n            cur = cur->next;\n        }\n        addTwoNumbers(head, cur, l1 == nullptr ? l1 : l1->next, l2 == nullptr ? l2 : l2->next, carry / 10);\n    }\n};\n")))}s.isMDXComponent=!0}}]);